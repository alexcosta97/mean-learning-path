# Adapting an Application for Passport Authentication

## Adapting the User model
In order to use the User model in our MEAN applications, we'll have to modify it to address a few authentication process requirements. These changes will include modifying UserSchema, adding a pre middleware and adding some new instance methods. To do so, we have to fo to our user model file and change it as follows:

```javascript
var mongoose = require('mongoose');
var crypto = require('crypto');
var Schema = mongoose.Schema;

var UserSchema = new Schema({
    firstName: String,
    lastName: String,
    email: {
        type: String,
        match: [/.+\@.+\..+/, "Please fill a valid e-mail address"]
    },
    username: {
        type: String,
        unique: true,
        required: 'Username is required',
        trim: true
    },
    password: {
        type: String,
        validate: [function(password){
            return password && password.length > 6;
        }, 'Passoword should be longer']
    },
    salt: {
        type: String
    },
    provider: {
        type: String,
        required: 'Provider is required'
    },
    providerId: String,
    providerData: {},
    created: {
        type: Date,
        default: Date.now
    }
});

UserSchema.virtual('fullName').get(function(){
    return this.firstName + ' ' + this.lastName;
}).set(function(fullName){
    var splitName = fullName.split(' ');
    this.firstName = splitName[0] || '';
    this.lastName = splitName[1] || '';
});

UserSchema.pre('save', function(next){
    if (this.password){
        this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
        this.password = this.hashPassword(this.password);
    }
    next();
});

UserSchema.methods.hashPassword = function(password){
    return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
};

UserSchema.methods.authenticate = function(password){
    return this.password === this.hashPassword(password);
};

UserSchema.statics.findUniqueUsername = function(username, suffix, callback){
    var _this = this;
    var possibleUsername = username + (suffix || '');

    _this.findOne({
        username: possibleUsername
    }, function(err, user){
        if(!err){
            if(!user){
                callback(possibleUsername);
            } else{
                return _this.findUniqueUsername(username, (suffix || 0) + 1, callback);
            }
        } else{
            callback(null);
        }
    });
};

UserSchema.set('toJSON', {
    getters: true.
    virtuals : true
});

mongoose.model('User', UserSchema);
```

The first change we did to the model was to add four field to the UserSchema: we added a `salt` property, which we'll use to hash our password, a `provider` property, which will indicate the strategy used to register the user, a `providerId` property, which will indicate the user identifier for the authentication strategy and a `providerData` property, which we'll later use to store the user object retrieved from OAuth providers.

Then we created a `pre-save` middleware to handle the hashing of the users' passwords. It is widely known that storing a clear text version of the users' passwords is a very bad practice that can result in the leakage of passwords. To handle that issue, the pre-save middleware performs two important thigns: it creates an autogenerated pseudo-random hashing salt, and then it replaces the current user password with a hashed password using the `hashPassword()` instance method.

We also added two instance methods: a `hashPassword()` instance method, which is used to hash a password string by utilizing Node's `crypto` module, and an `authenticate()` instance method, which accepts a string argument, hashes it, and compares it to the current user's hashed password. Finally, we added the `findUniqueUsername()` static method, which is used to find an available unique username for new users. We'll use this method later when dealing with OAuth authentication.

## Creating the authentication views
Just like with any web application, we'll need to have signup and sign-in pages in order to handle authentication. We'll crate those using the EJS template engine. In the `app/views` folder, we'll create a new file named `signup.ejs`. In the newly created file we can then add the following code:
```html
<!DOCTYPE html>
<html>
    <head>
        <title><%=title %></title>
    </head>
    <body>
        <% for(var i in messages){
            %> <div class="flash"><%= messages[i] %></div>
        <% } %>
        <form action="/signup" method="post">
            <div>
                <label>First Name:</label>
                <input type="text" name="firstName"/>
            </div>
            <div>
                <label>Last Name:</label>
                <input type="text" name="lastName"/>
            </div>
            <div>
                <label>Email:</label>
                <input type="text" name="email"/>
            </div>
            <div>
                <label>Username:</label>
                <input type="text" name="username"/>
            </div>
            <div>
                <label>Password:</label>
                <input type="password" name="password"/>
            </div>
            <div>
                <input type="submit" value="Sign up"/>
            </div>
        </form>
    </body>
</html>
```

The sign up view simply contains an HTML form, an EJS tag, which renders the title variable and an EJS loop, which renders the messages list variable. Going back to our `app/views` folder, we can then create another file, this time named `signin.ejs`. Inside the file, we insert the follwing code:
```html
<!DOCTYPE html>
<html>
    <head>
        <title><%=title %></title>
    </head>
    <body>
        <% for(var i in messages){
            <div class="flash"><%= messages[i] %></div>
        <% } %>
        <form action="/signin" method="post">
            <div>
                <label>Username:</label>
                <input type="text" name="username"/>
            </div>
            <div>
                <label>Password:</label>
                <input type="password" name="password"/>
            </div>
            <div>
                <input type="submit" value="Sign In" />
            </div>
        </form>
    </body>
</html>
```

This view is even simpler than the previous and also contains an HTML form, an EJS tag, which renders the title, and a loop which renders the messages list. Now that we have our models and views, we need to connect them with the Users controller.

## Modifying the user controller
To alter the users controller, we have to access the controller and change its content as follows:
```javascript
var User = require('mongoose').model('User');
var passport = require('passport');

var getErrorMessage = function(err){
    var message = '';
    if(err.code){
        switch(err.code){
            case 11000:
            case 11001:
                message = 'Username already exists';
            break;
            default:
                message = 'Something went wrong';
            break;
        }
    } else{
        for(var errName in err.errors){
            if(err.errors[errName].message){
                message = err.errors[errName].message;
            }
        }
    }
    return message;
};

exports.renderSignin = function(req, res, next){
    if(!req.user){
        res.render('signin', {
            title: 'Sign-in Form',
            messages: req.flash('error') || req.flash('info')
        });
    } else{
        return res.redirect('/');
    }
};

exports.renderSignup = function(req, res, next){
    if(!req.user){
        res.render('signup', {
            title: 'Sign-up Form',
            messages: req.flash('error')
        });
    } else{
        return res.redirect('/');
    }
};

exports.signup = function(req, res, next){
    if(!req.user){
        var user = new User(req.body);
        var messages = null;
        user.provider = 'local';

        user.save(function(err){
            if(err){
                var message = getErrorMessage(err);
                req.flash('error', message);
                return res.redirect('/signup');
            }
            req.login(user, function(err){
                if(err){
                    return next(err);
                }
                return res.redirect('/');
            });
        });
    } else{
        return res.redirect('/');
    }
};

exports.signout = function(req, res){
    req.logout();
    res.redirect('/');
};
```

The `getErrorMessage()` method is a private method that returns a unified error message from a Mongoose error object. It is worth noticing that there are two possible errors here: a MongoDB indexing error handled using the error code and a Mongoose validation error handled using the `err.errors` object.

The next two controller methods are quite simple and will be used to render the sign-in and signup pages. The `signout()` method is also simple and uses the `req.logout()` method, which is provided by the Passport module to invalidate the authenticated session.

The `signup()` method uses the User model to create new users. It first creates a user object from the HTTP request body. Then, it tries saving it to MongoDB. If an error occurs, the `signup()` method will use the `getErrorMessages()` method to provide the user with an appropriate error message. If the user creation was successful, the user session will be created using the `req.login()` method. That method is exposed by Passport and is used to establish a succssful login session. After the login operation is completed, a user object will be signed to the `req.user` object.

Usually, the `req.login()` method is automatically called while using `passport.authenticate()`, so a manual call for it is only necessary when registering new users.

A unfamiliar module was also used in this code. When an authentication process is failing, it is common to redirect the request back to the signup or sign-in pages. This is done here when an error occurs, but how can we tell the user exactly what went wrong? The problem comes from the fact that when we redirect pages, we cannot pass variables to that page. The solution would then be to use some sort of mechanism to pass temporary messages between requests. That mechanism exists in the form of a module called `Connect-Flash`.

### Displaying flash error messages
The `Connect-Flash` module is a node module that allows us to store temporary messages in an area of the session object called `flash`. Messages stored on that object will be cleared once they are presented to the suer. This architecture makes the module perfect to transfer messages before redirecting the request to another page.

#### Installing the module
To install the module in our application, we need to add the following dependency in the `package.json` file:
```json
    "connect-flash": "~0.1.1"
```
Then, as usual, we need to run `npm install` to install the module. The next step is to configure the application to use the module.

#### Configuring Connect-Flash module
To configure our Express application to use the new module, we'll have to require the new module in our Express configuration file and use the `app.use()` method to register it in the application. To do that we only need to add the following two lines of code in the express configuration file:
```javascript
var flash = require('connect-flash');

...
app.use(flash());
```

#### Using Connect-Flash module
Once the module is installed, the module exposes the `req.flash()` method, which allows us to create and retrieve flash messages. To understand it better, we can see how it behaves in the `renderSignin()` and `renderSignup()` methods in the controller.

In those methods, the `res.render()` method is executed with the `title` and `messages` variables. The messages variable uses `req.flash()` to read the messages written into the flash. Now if we look at the `signup()` method, we can notice that we also use `req.flash()` to write the error messages to the flash.

Now that we know how the new controller works, we can wrap up the authentication process by adding the routes to the users' controller.

## Wiring the user's routes
Once we have the model, controller and views in place, all we need to do is define the user's routes. To do so, we need to modify the users' routes file in the following way:
```javascript
var users = require('../../app/controllers/users.server.controller');
var passport = require('passport');

module.exports = function(app){
    app.route('/signup').get(users.renderSignup).post(users.signup);

    app.route('/signin').get(users.renderSignin).post(passport.authenticate('local', {
        successRedirect: '/',
        failureRedirect: '/signin',
        failureFlash: true
    }));

    app.get('/signout', users.signout);
};
```

Most of the route definitions here are basically directing to methods from the users' controller. The only different route is the one where any `POST` request made to the sign-in path uses the `passport.authenticate()` method.

When that method is executed, it will try to authenticate the user request using the strategy defined by its first argument. In this case, it will try to authenticate the request using the local strategy. The second parameter this method accepts is an `options` object, which contains three properties:
* `sucessRedirect`: This property tells Passport where to redirect the request once it successfully authenticated the user
* `failureRedirect`: This property tells Passport where to redirect the request once it failed to authenticate the user
* `failureFlash`: This property tells Passport whether or not to use flash messages

Now that the routes are set up, in order to test the application authenticatino, we need to make the following changes to the index controller:
```javascript
exports.render = function(req, res){
    res.render('index', {
        title: 'Hello World',
        userFullName: req.user ? req.user.fullName : ''
    });
};
```

This will pass the authenticated user's full name to the home page themplate. Then we can also make the follwing changes to the index view:
```html
<!DOCTYPE html>
<html>
    <head>
        <title><%= title%></title>
    </head>
    <body>
        <% if(userFullName) { %>
            <h2>Hello <%=userFullName%></h2>
            <a href="/signout">Sign out</a>
        <% } else {%>
            <a href="/signup">Signup</a>
            <a href="/signin">Signin</a>
        <% } %>
        <img src="img/logo.png" alt="Logo">
    </body>
</html>
```

Now we just need to test the application by running the command `node server` from the command-line at the root of the project.

Next: [Understanding Passport OAuth strategies](passportOAuthStrategies.md)